call plug#begin()
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-vinegar'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-fugitive'
Plug 'itchyny/lightline.vim'
Plug 'Quramy/tsuquyomi'
Plug 'arcticicestudio/nord-vim'
Plug 'editorconfig/editorconfig-vim'
Plug 'airblade/vim-gitgutter'
Plug 'mileszs/ack.vim'
Plug 'w0rp/ale'
Plug 'vim-ruby/vim-ruby'
Plug 'leafgarland/typescript-vim'
Plug 'elixir-editors/vim-elixir'
Plug 'pangloss/vim-javascript'
Plug 'mxw/vim-jsx'

call plug#end()

colorscheme nord

filetype plugin indent on
set sw=4
set ts=4

" Prevent Vim from clobbering the scrollback buffer. See
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=

"Cursor
let &t_SI.="\e[5 q" "SI = INSERT mode
let &t_SR.="\e[4 q" "SR = REPLACE mode
let &t_EI.="\e[1 q" "EI = NORMAL mode (ELSE)

"Auto completion
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>

"Searching
set incsearch
set hlsearch
nnoremap <leader><leader> :nohlsearch<cr>

"Movement
nnoremap E $

nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" Because I often accidentally :W when I mean to :w.
command! W w

"Backup & undo - https://coderwall.com/p/sdhfug/vim-swap-backup-and-undo-files
set undodir=~/.vim/.undo//
set backupdir=~/.vim/.backup//
set directory=~/.vim/.swp//

" Leader
let mapleader=","

" Run a given vim command on the results of fuzzy selecting from
" a given shell command. See usage below. Credit: Gary Bernhardt
function! SelectaCommand(choice_command, selecta_args, vim_command)
  try
    let selection = system(a:choice_command . " | selecta " . a:selecta_args)
  catch /Vim:Interrupt/
    " Swallow the ^C so that the redraw below happens
    " otherwise, there will be leftovers from selecta on the screen
    redraw!
    return
  endtry
  redraw!
  exec a:vim_command . " " . selection
endfunction

" Find all files in all non-dot directories in the working directory.
" Fuzzy select one of those. Open the selected file with :e.
let fileCommand = 'find * -type f | grep -v "\(node_modules\|vendor\|tmp\|git\|public\)"'
nnoremap <leader>t :call SelectaCommand(fileCommand, "", ":e")<cr>

com! FormatJSON %!python -m json.tool

noremap <leader>s :update<cr>
noremap <Leader>a :Ack <cword><cr>

set ignorecase smartcase

set nowrap
set number
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set autoindent

" Typescript
nnoremap <leader>d :TsuDefinition<cr>
nnoremap <leader>D :TsuTypeDefinition<cr>
nnoremap <leader>r :TsuReferences<cr>
nnoremap <leader>rn :TsuRenameSymbol<cr>
nnoremap <leader>b :TsuGoBack<cr>

set encoding=utf-8  " The encoding displayed.
set fileencoding=utf-8  " The encoding written to file.

" ale
let g:ale_fixers = {
\   'typescript': ['prettier'],
\   'html': ['prettier'],
\   'css': ['prettier'],
\}

let g:ale_linters = {'typescript': ['tsserver']}
let g:ale_lint_on_text_changed = 'normal'
let g:ale_lint_on_insert_leave = 1
let g:ale_lint_delay = 0

let g:ale_fix_on_save = 1
let g:ale_sign_column_always = 1
let g:tsuquyomi_disable_quickfix = 1

nnoremap g1 :silent! :silent! :ll 1\|:normal zz<cr>
nnoremap gj :silent! :ll\|:silent! :lnext\|:normal zz<cr>
nnoremap gk :silent! :ll\|:silent! :lprev\|:normal zz<cr>

autocmd FileType typescript nmap <buffer> <Leader>h : <C-u>echo tsuquyomi#hint()<CR>

" lightline
set noshowmode
let g:lightline = {
      \ 'colorscheme': 'nord',
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'gitbranch', 'readonly', 'filename', 'modified' ] ],
      \   'right': [['lineinfo'],['percent'],['filetype']]
      \ },
      \ 'component_function': {
      \   'gitbranch': 'fugitive#head'
      \ },
      \ }
